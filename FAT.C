#include <stdlib.h>
#include <mem.h>
#include <string.h>

#include "isadma.h"
#include "8format.h"

/* JMP SHORT, nop and the BIOS parameter block. Drive geometry to be modified (5,25" 360K originally) */
const unsigned char sBIOSParameterBlock[54] =
{
    0xEB, 0x34, 0x90, 0x4D, 0x53, 0x44, 0x4F, 0x53, 0x33, 0x2E, 0x33, 0x00, 0x02, 0x02, 0x01, 0x00, 
    0x02, 0x70, 0x00, 0xD0, 0x02, 0xFD, 0x02, 0x00, 0x09, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x12, 
    0x00, 0x00, 0x00, 0x00, 0x01, 0x00 
};

/* 128byte bootstrapper (74 bytes, excl. the BPB) + separate 384 byte bootcode */
unsigned char s128ByteBootstrapper[458] =
{
    0xFA, 0xFC, 0x31, 0xDB, 0x8E, 0xD3, 0xBC, 0x00, 0x7C, 0x0E, 0x1F, 0x1E, 0x07, 0xFB, 0xBE, 0x63, 
    0x7C, 0xB4, 0x0E, 0xAC, 0x3C, 0x55, 0x74, 0x08, 0x56, 0x55, 0xCD, 0x10, 0x5D, 0x5E, 0xEB, 0xF1, 
    0xB8, 0x03, 0x02, 0xB9, 0x02, 0x00, 0xBB, 0x80, 0x7C, 0xCD, 0x13, 0xEB, 0x1D, 0x38, 0x22, 0x20, 
    0x64, 0x69, 0x73, 0x6B, 0x3A, 0x20, 0x42, 0x6F, 0x6F, 0x74, 0x73, 0x74, 0x72, 0x61, 0x70, 0x70, 
    0x69, 0x6E, 0x67, 0x2E, 0x2E, 0x2E, 0x0D, 0x0A, 0x55, 0xAA, 0xFA, 0x31, 0xC0, 0x90, 0x88, 0x16, 
    0xD7, 0x7D, 0xBB, 0x78, 0x00, 0x36, 0xC5, 0x37, 0xBF, 0x2B, 0x7C, 0xB9, 0x0B, 0x00, 0xFC, 0xAC, 
    0x26, 0x80, 0x3D, 0x00, 0x74, 0x03, 0x26, 0x8A, 0x05, 0xAA, 0x88, 0xE0, 0xE2, 0xF1, 0x06, 0x1F, 
    0x89, 0x47, 0x02, 0xC7, 0x07, 0x2B, 0x7C, 0xFB, 0xCD, 0x13, 0x72, 0x6B, 0xA0, 0x10, 0x7C, 0x98, 
    0xF7, 0x26, 0x16, 0x7C, 0x03, 0x06, 0x1C, 0x7C, 0x03, 0x06, 0x0E, 0x7C, 0xA3, 0x3F, 0x7C, 0xA3, 
    0x37, 0x7C, 0xB8, 0x20, 0x00, 0xF7, 0x26, 0x11, 0x7C, 0x8B, 0x1E, 0x0B, 0x7C, 0x01, 0xD8, 0x48, 
    0xF7, 0xF3, 0x01, 0x06, 0x37, 0x7C, 0xBB, 0x00, 0x05, 0xA1, 0x3F, 0x7C, 0xE8, 0xA3, 0x00, 0xB8, 
    0x01, 0x02, 0xE8, 0xB7, 0x00, 0x72, 0x1D, 0x89, 0xDF, 0xB9, 0x0B, 0x00, 0xBE, 0xC1, 0x7D, 0xF3, 
    0xA6, 0x75, 0x11, 0x8D, 0x7F, 0x20, 0xEB, 0x02, 0x55, 0xAA, 0xBE, 0xCC, 0x7D, 0xB9, 0x0B, 0x00, 
    0xF3, 0xA6, 0x74, 0x18, 0xBE, 0xD8, 0x7D, 0xE8, 0x6A, 0x00, 0x30, 0xE4, 0xCD, 0x16, 0xEA, 0x00, 
    0xF0, 0xFF, 0xFF, 0x90, 0x90, 0x90, 0x90, 0xBE, 0xF1, 0x7D, 0xEB, 0xEB, 0xA1, 0x1C, 0x05, 0x31, 
    0xD2, 0xF7, 0x36, 0x0B, 0x7C, 0xFE, 0xC0, 0xA2, 0x3C, 0x7C, 0xA1, 0x37, 0x7C, 0xA3, 0x3D, 0x7C, 
    0xBB, 0x00, 0x07, 0xA1, 0x37, 0x7C, 0xE8, 0x49, 0x00, 0xA1, 0x18, 0x7C, 0x2A, 0x06, 0x3B, 0x7C, 
    0x40, 0x38, 0x06, 0x3C, 0x7C, 0x73, 0x03, 0xA0, 0x3C, 0x7C, 0x50, 0xE8, 0x4E, 0x00, 0x58, 0x72, 
    0xC6, 0x28, 0x06, 0x3C, 0x7C, 0x74, 0x0C, 0x01, 0x06, 0x37, 0x7C, 0xF7, 0x26, 0x0B, 0x7C, 0x01, 
    0xC3, 0xEB, 0xD0, 0x8A, 0x2E, 0x15, 0x7C, 0x8A, 0x16, 0xD7, 0x7D, 0x8B, 0x1E, 0x3D, 0x7C, 0xEA, 
    0x00, 0x00, 0x70, 0x00, 0xAC, 0x08, 0xC0, 0x74, 0x22, 0xB4, 0x0E, 0xBB, 0x07, 0x00, 0xCD, 0x10, 
    0xEB, 0xF2, 0x31, 0xD2, 0xF7, 0x36, 0x18, 0x7C, 0xFE, 0xC2, 0x88, 0x16, 0x3B, 0x7C, 0x31, 0xD2, 
    0xF7, 0x36, 0x1A, 0x7C, 0x88, 0x16, 0x2A, 0x7C, 0xA3, 0x39, 0x7C, 0xC3, 0xB4, 0x02, 0x8B, 0x16, 
    0x39, 0x7C, 0xB1, 0x06, 0xD2, 0xE6, 0x0A, 0x36, 0x3B, 0x7C, 0x89, 0xD1, 0x86, 0xE9, 0x8A, 0x16, 
    0xD7, 0x7D, 0x8A, 0x36, 0x2A, 0x7C, 0xCD, 0x13, 0xC3, 0x90, 0x90, 0x49, 0x4F, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x53, 0x59, 0x53, 0x4D, 0x53, 0x44, 0x4F, 0x53, 0x20, 0x20, 0x20, 0x53, 0x59, 
    0x53, 0x00, 0x0D, 0x0A, 0x49, 0x4F, 0x2F, 0x4D, 0x53, 0x44, 0x4F, 0x53, 0x2E, 0x53, 0x59, 0x53, 
    0x20, 0x6E, 0x6F, 0x74, 0x20, 0x66, 0x6F, 0x75, 0x6E, 0x64, 0x00, 0x0D, 0x0A, 0x52, 0x65, 0x61, 
    0x64, 0x20, 0x66, 0x61, 0x69, 0x6C, 0x00, 0x00, 0x55, 0xAA
};

/* Regular "512byte"-compatible FAT12 boot code (to be put in a 512/1024B sector). Searches for IO.SYS/MSDOS.SYS */
const unsigned char sFAT12BootCode[439] =
{
    0xFA, 0x33, 0xC0, 0x8E, 0xD0, 0xBC, 0x00, 0x7C, 0x16, 0x07, 0xBB, 0x78, 0x00, 0x36, 0xC5, 0x37, 
    0x1E, 0x56, 0x16, 0x53, 0xBF, 0x2B, 0x7C, 0xB9, 0x0B, 0x00, 0xFC, 0xAC, 0x26, 0x80, 0x3D, 0x00, 
    0x74, 0x03, 0x26, 0x8A, 0x05, 0xAA, 0x8A, 0xC4, 0xE2, 0xF1, 0x06, 0x1F, 0x89, 0x47, 0x02, 0xC7, 
    0x07, 0x2B, 0x7C, 0xFB, 0xCD, 0x13, 0x72, 0x67, 0xA0, 0x10, 0x7C, 0x98, 0xF7, 0x26, 0x16, 0x7C, 
    0x03, 0x06, 0x1C, 0x7C, 0x03, 0x06, 0x0E, 0x7C, 0xA3, 0x3F, 0x7C, 0xA3, 0x37, 0x7C, 0xB8, 0x20, 
    0x00, 0xF7, 0x26, 0x11, 0x7C, 0x8B, 0x1E, 0x0B, 0x7C, 0x03, 0xC3, 0x48, 0xF7, 0xF3, 0x01, 0x06, 
    0x37, 0x7C, 0xBB, 0x00, 0x05, 0xA1, 0x3F, 0x7C, 0xE8, 0x9F, 0x00, 0xB8, 0x01, 0x02, 0xE8, 0xB3, 
    0x00, 0x72, 0x19, 0x8B, 0xFB, 0xB9, 0x0B, 0x00, 0xBE, 0xD6, 0x7D, 0xF3, 0xA6, 0x75, 0x0D, 0x8D, 
    0x7F, 0x20, 0xBE, 0xE1, 0x7D, 0xB9, 0x0B, 0x00, 0xF3, 0xA6, 0x74, 0x18, 0xBE, 0x77, 0x7D, 0xE8, 
    0x6A, 0x00, 0x32, 0xE4, 0xCD, 0x16, 0x5E, 0x1F, 0x8F, 0x04, 0x8F, 0x44, 0x02, 0xCD, 0x19, 0xBE, 
    0xC0, 0x7D, 0xEB, 0xEB, 0xA1, 0x1C, 0x05, 0x33, 0xD2, 0xF7, 0x36, 0x0B, 0x7C, 0xFE, 0xC0, 0xA2, 
    0x3C, 0x7C, 0xA1, 0x37, 0x7C, 0xA3, 0x3D, 0x7C, 0xBB, 0x00, 0x07, 0xA1, 0x37, 0x7C, 0xE8, 0x49, 
    0x00, 0xA1, 0x18, 0x7C, 0x2A, 0x06, 0x3B, 0x7C, 0x40, 0x38, 0x06, 0x3C, 0x7C, 0x73, 0x03, 0xA0, 
    0x3C, 0x7C, 0x50, 0xE8, 0x4E, 0x00, 0x58, 0x72, 0xC6, 0x28, 0x06, 0x3C, 0x7C, 0x74, 0x0C, 0x01, 
    0x06, 0x37, 0x7C, 0xF7, 0x26, 0x0B, 0x7C, 0x03, 0xD8, 0xEB, 0xD0, 0x8A, 0x2E, 0x15, 0x7C, 0x8A, 
    0x16, 0xFD, 0x7D, 0x8B, 0x1E, 0x3D, 0x7C, 0xEA, 0x00, 0x00, 0x70, 0x00, 0xAC, 0x0A, 0xC0, 0x74, 
    0x22, 0xB4, 0x0E, 0xBB, 0x07, 0x00, 0xCD, 0x10, 0xEB, 0xF2, 0x33, 0xD2, 0xF7, 0x36, 0x18, 0x7C, 
    0xFE, 0xC2, 0x88, 0x16, 0x3B, 0x7C, 0x33, 0xD2, 0xF7, 0x36, 0x1A, 0x7C, 0x88, 0x16, 0x2A, 0x7C, 
    0xA3, 0x39, 0x7C, 0xC3, 0xB4, 0x02, 0x8B, 0x16, 0x39, 0x7C, 0xB1, 0x06, 0xD2, 0xE6, 0x0A, 0x36, 
    0x3B, 0x7C, 0x8B, 0xCA, 0x86, 0xE9, 0x8A, 0x16, 0xFD, 0x7D, 0x8A, 0x36, 0x2A, 0x7C, 0xCD, 0x13, 
    0xC3, 0x0D, 0x0A, 0x4E, 0x6F, 0x6E, 0x2D, 0x53, 0x79, 0x73, 0x74, 0x65, 0x6D, 0x20, 0x64, 0x69, 
    0x73, 0x6B, 0x20, 0x6F, 0x72, 0x20, 0x64, 0x69, 0x73, 0x6B, 0x20, 0x65, 0x72, 0x72, 0x6F, 0x72, 
    0x0D, 0x0A, 0x52, 0x65, 0x70, 0x6C, 0x61, 0x63, 0x65, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x73, 0x74, 
    0x72, 0x69, 0x6B, 0x65, 0x20, 0x61, 0x6E, 0x79, 0x20, 0x6B, 0x65, 0x79, 0x20, 0x77, 0x68, 0x65, 
    0x6E, 0x20, 0x72, 0x65, 0x61, 0x64, 0x79, 0x0D, 0x0A, 0x00, 0x0D, 0x0A, 0x44, 0x69, 0x73, 0x6B, 
    0x20, 0x42, 0x6F, 0x6F, 0x74, 0x20, 0x66, 0x61, 0x69, 0x6C, 0x75, 0x72, 0x65, 0x0D, 0x0A, 0x00, 
    0x49, 0x4F, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x53, 0x59, 0x53, 0x4D, 0x53, 0x44, 0x4F, 0x53, 
    0x20, 0x20, 0x20, 0x53, 0x59, 0x53, 0x00
};

/* To be used from the BPB, locally */
unsigned int nReservedSectors = 0;
unsigned int nRootDirEntries = 0;
unsigned int nSectorsPerFAT = 0;
unsigned int nBytesPerCluster = 0;

/* Total disk capacity and free space */
unsigned long nTotalDiskCapacity = 0;
unsigned long nTotalDiskSpace = 0;

/* FAT signature */
unsigned char sFATSignature[3] =
{
    0xFE, 0xFF, 0xFF
};

void PrepareBPB()
{
  /* Initialize pointers to values that need to be redefined */
  unsigned int* pBytesPerSector = (unsigned int*)(&(pDMABuffer)[0x0b]);
  unsigned char* pSectorsPerCluster = (unsigned char*)(&(pDMABuffer)[0x0d]);  
  unsigned int* pReservedSectors = (unsigned int*)(&(pDMABuffer)[0x0e]);
  unsigned int* pRootDirEntries = (unsigned int*)(&(pDMABuffer)[0x11]);
  unsigned int* pTotalSectors = (unsigned int*)(&(pDMABuffer)[0x13]);
  unsigned char* pMediaDescriptor = (unsigned char*)(&(pDMABuffer)[0x15]);
  unsigned int* pSectorsPerFAT = (unsigned int*)(&(pDMABuffer)[0x16]);
  unsigned int* pSectorsPerTrack = (unsigned int*)(&(pDMABuffer)[0x18]);
  unsigned int* pNumberOfHeads = (unsigned int*)(&(pDMABuffer)[0x1a]);
  
  /* Initialize with default values (5,25" 360K) and start defining the 8" geometry */
  memcpy(pDMABuffer, sBIOSParameterBlock, sizeof(sBIOSParameterBlock));
  
  /* Common values for 77-track 8"s */
  *pNumberOfHeads = (unsigned int)nHeads; 
  *pSectorsPerTrack = (unsigned int)nSectorsPerTrack;
  *pBytesPerSector = nLogicalSectorSize;
  *pTotalSectors = (unsigned int)nLogicalSectorsPerTrack * nHeads * (unsigned int)nTracks;
  
  /* 250kB SSSD (TYPE DSSD /1) */
  if ((strcmp(sFormatType, "DSSD") == 0) && (nHeads == 1))
  {
    *pSectorsPerCluster = 4;
    *pReservedSectors = 4;
    *pMediaDescriptor = 0xfe;
    *pSectorsPerFAT = 4;
  }

  /* 500kB TYPE DSSD */
  else if ((strcmp(sFormatType, "DSSD") == 0) && (nHeads == 2))
  {
    *pSectorsPerCluster = 4;
    *pReservedSectors = 4;
    *pMediaDescriptor = 0xfd;
    *pSectorsPerFAT = 4;
  }
  
  /* 1.2MB TYPE DSDD, DSDD /1 */
  else if (strcmp(sFormatType, "DSDD") == 0)
  {
    *pSectorsPerCluster = 1;
    *pReservedSectors = 1;
    *pMediaDescriptor = 0xfe;
    *pSectorsPerFAT = 2;
  }
  
  /* 1.2MB EXT1, EXT1 /1, 1.3MB CRAM UNDOCUMENTED */
  else if ((strcmp(sFormatType, "EXT1") == 0) || (strcmp(sFormatType, "CRAM") == 0))
  {
    *pSectorsPerCluster = 1;
    *pReservedSectors = 1;
    *pMediaDescriptor = 0xf9;
    *pSectorsPerFAT = 8;
  }
  
  /* 1.0MB EXT2, EXT2 /1 */
  else if (strcmp(sFormatType, "EXT2") == 0)
  {
    *pSectorsPerCluster = 2;
    *pReservedSectors = 2;
    *pMediaDescriptor = 0xf0;
    *pSectorsPerFAT = 4;
  }
  
  /* 693kB EXT3, EXT3 /1 */
  else
  {
    *pSectorsPerCluster = 2;
    *pReservedSectors = 1;
    *pMediaDescriptor = 0xf9;
    *pSectorsPerFAT = 4;
  }
  
  /* Compute the maximum number of 32-byte root directory entries */
  *pRootDirEntries = (nLogicalSectorsPerTrack - *pReservedSectors - *pSectorsPerFAT + 1) * nLogicalSectorSize / 32;
  
  nReservedSectors = *pReservedSectors;
  nRootDirEntries = *pRootDirEntries;
  nSectorsPerFAT = *pSectorsPerFAT;
  nBytesPerCluster = *pSectorsPerCluster * nLogicalSectorSize;
  nTotalDiskCapacity = (unsigned long)(*pTotalSectors) * nLogicalSectorSize;
  
  /* 0xf0 "Superfloppy" media descriptor if /512PH was used */
  if (nPhysicalSectorSize != nLogicalSectorSize)
  {
    *pMediaDescriptor = 0xf0;
  }
  
  /* Change FAT ID to media descriptor from BPB */
  sFATSignature[0] = *pMediaDescriptor;
}

void WriteBootCode()
{
  /* Write a single 512/1024-byte bootsector, four 128-byte sectors or two 256-byte sectors. */
  unsigned char* pAfterBPB = &(pDMABuffer)[0x36];
    
  /* Prepare the BIOS parameter block (drive geometry) */
  PrepareBPB();
  
  /* 128B or 256B-per-sector floppy require a special "bootstrapper"
     This is pre-signed with 0xaa55 on the 127th and 255th bytes, to be able to be booted from. */
  if (nPhysicalSectorSize < 512)
  {
    unsigned char nSectorIdx = 1;
    unsigned int nBytesWritten = 0;
    
    /* Experimental 256byte sector support */
    if (nPhysicalSectorSize == 256)
    {
      /* Modify the boot code to load one sector to 7d00h
         defaultly: load three sectors to 7c80h (3x 128B) */
      s128ByteBootstrapper[33] = 0x01; /* was 0x03 (INT 0x13, AH=02 Read Sectors, AL=1 instead of 3) */
      s128ByteBootstrapper[40] = 0x7D; /* was 0x7c (Offset to load to: 0x7d00 instead of 0x7c80) */
      s128ByteBootstrapper[39] = 0x00; /* was 0x80 */
    }
    
    /* The BIOS only loads one sector CHS 0/0/1 upon boot... So load 3 more sectors (128B size)
       or 1 more sector (256B size), to get a complete 512B boot routine. */
    memcpy(pAfterBPB, s128ByteBootstrapper, nPhysicalSectorSize-sizeof(sBIOSParameterBlock) /* 54 */);
    
    /* On track 0, head 0 */
    FDDSeek(0, 0);
    
    for(;;)
    {
      /* Complete boot routine */
      int nRemainingBytes;
      
      /* Write one 128B/256B sector */
      FDDWrite(nSectorIdx++);
      
      /* Length of first part: 54 bytes BPB + the rest of the sector size */
      if (nBytesWritten == 0)
      {
        nBytesWritten += nPhysicalSectorSize-sizeof(sBIOSParameterBlock);
      }
      else
      {
        nBytesWritten += nPhysicalSectorSize; /* 128 or 256 */
      }
      
      nRemainingBytes = sizeof(s128ByteBootstrapper) - nBytesWritten;      
      if (nRemainingBytes <= 0)
      {
        /* Done */
        break;
      }
      
      /* Next 128/256byte part */
      memcpy(pDMABuffer,
             &(s128ByteBootstrapper)[nBytesWritten],
             (nRemainingBytes > nPhysicalSectorSize) ? nPhysicalSectorSize : nRemainingBytes); 
    }
  }
  
  /* Classic bootsector code (fits a >=512-byte sector) */
  else
  {    
    /* Needs to be signed manually at the end of the sector */
    unsigned int* pSignatureBPB = (unsigned int*)(&(pDMABuffer)[nPhysicalSectorSize-2]);
    
    /* Copy classic bootsector */
    memcpy(pAfterBPB, sFAT12BootCode, sizeof(sFAT12BootCode));
    
    /* Bootable sector signature for BIOS */
    *pSignatureBPB = 0xaa55;
    
    /* Write one sector on track 0, head 0, sector no: 1 */
    FDDSeek(0, 0);
    FDDWrite(1);
  }  
}

void WriteRootDir()
{ 
  /* Start of the FAT region */
  unsigned char nSectorIdx = (unsigned char)nReservedSectors + 1;
  
  unsigned int nReservedLength = 0;  
  unsigned int nBytesWritten = 0;  
  unsigned char nHead = 0;
  unsigned char nTrack = 0;
  
  /* Disk write buffer length: 2 FATs + root directory length. */
  const unsigned int nBufferLen = (2 * nSectorsPerFAT * nLogicalSectorSize) + (nRootDirEntries * 32);
  
  /* Allocate disk write buffer */
  unsigned char* pBuffer = (unsigned char*)calloc(nBufferLen, sizeof(unsigned char));
  if (!pBuffer)
  {
    printf("\nMemory allocation error\n");
    Quit(EXIT_FAILURE);
  }
  
  /* Physical sector size not equivalent to logical? This means that 512B physical sectors are forced.
     As such, set that the FAT region starts at sector 2 (one bootsector is reserved). */
  if (nPhysicalSectorSize != nLogicalSectorSize)
  {
    nSectorIdx = 2;
    nReservedLength = 512;
  }
  else
  {
    /* Compute bootsector/reserved sectors length in bytes */
    nReservedLength = (unsigned int)nReservedSectors * nLogicalSectorSize;
  }
 
  /* Sign two FATs */
  memcpy(&pBuffer[0], sFATSignature, sizeof(sFATSignature));
  memcpy(&pBuffer[nSectorsPerFAT*nLogicalSectorSize], sFATSignature, sizeof(sFATSignature));
  
  /* Write logical format to disk */
  while (nBytesWritten < nBufferLen)
  {
    /* Copy memory for the whole sector size, or just the remainder */
    unsigned int nCopyCount = abs(nBytesWritten-nBufferLen);
    if (nCopyCount > nPhysicalSectorSize)
    {
      nCopyCount = nPhysicalSectorSize;
    }
    
    /* DMA buffer filled with format byte (to mark "unwritten" stuff, instead of zeros) */
    memset(pDMABuffer, nFormatByte, 1024);
    
    /* Need to advance to the next head (or track) ? */
    if (nSectorIdx > nSectorsPerTrack)
    {
      nSectorIdx = 1;
      nHead++;
      
      if (nHead > nHeads-1)
      {
        nHead = 0;
        FDDSeek(++nTrack, nHead);     
      }
      else
      {
        FDDSeek(nTrack, nHead);
      }
    }
    
    /* Copy memory for writing */
    memcpy(&pDMABuffer[0], &pBuffer[nBytesWritten], nCopyCount);

    /* Write FATs/root directory in nPhysicalSectorSize chunks */
    FDDWrite(nSectorIdx++);    
    nBytesWritten += nCopyCount;
  }
  
  free(pBuffer);
  
  /* Compute free disk space (total capacity minus reserved length/bootsector(s), FATs and root dir) */
  nTotalDiskSpace = nTotalDiskCapacity - nReservedLength - nBytesWritten;
}

void DisplayDiskInformation()
{
  /* FAT information */
  printf("\nUsing a %uB logical sector size on %uB-sectored physical media (ID: 0x%02X)\n"
         "with 2 FATs, a FAT cluster size of %u bytes, %u reserved logical sector(s),\n"
         "%u logical sectors per FAT and %u root directory entries.\n",
         nLogicalSectorSize, nPhysicalSectorSize, sFATSignature[0],
         nBytesPerCluster, nReservedSectors,
         nSectorsPerFAT, nRootDirEntries);
         
  /* Disk space */
  printf("\n   %7lu bytes (%luK) total disk capacity,\n   %7lu bytes (%luK) usable space.\n\n",
         nTotalDiskCapacity, nTotalDiskCapacity / 1024, nTotalDiskSpace, nTotalDiskSpace / 1024);
}

void WriteFAT12()
{     
  /* Clear the 8K DMA buffer */
  memset(pDMABuffer, 0, 8*1024);
  
  /* Write FAT12 bootsector */
  WriteBootCode();

  /* Write an empty root directory */
  WriteRootDir();
  
  /* Inform about free space */
  DisplayDiskInformation();
}